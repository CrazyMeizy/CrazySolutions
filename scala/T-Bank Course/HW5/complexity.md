# Анализ сложности
## Предисловие

В этом домашнем задании использован алгоритм скользящего окна на минимум. С тем как он работает можно ознакомиться по ссылке: https://codeforces.net/blog/entry/71687 (Решение #2). Здесь я лишь оценю сложность реализованного алгоритма на Scala.
## Решение 1

### Временная сложность
Первое решение использует метод `sliding`, предоставляемый `scala.collection.immutable.List[A]`, 
который создает скользящее окно по входной последовательности. 
Для каждого окна размером `width` вычисляется максимальное значение 
с помощью метода `max`. Итого сложность решения составляет O(N * W).
где:
- N — количество элементов во входном списке.
- W — ширина скользящего окна.

В худшем случае W = N/2. Тогда сложность решения - O(N ^ 2).



### Пространственная сложность
Пространственная сложность зависит от размера списка, создаваемого с помощью `toList`, 
который хранит результаты максимальных значений для каждого скользящего окна. 
Мы уже поняли, что в худшем случае их может быть порядка O(N).

## Решение 2

### Временная сложность
Второе решение реализовано с использованием 2 стеков. Добавление и удаление в такой структуре данных выполняется за константу. 

Нет нужды в том, чтобы объяснять почему и как работает алгоритм, 
а просто посчитаем, какие действия производятся с 1 элементом списка в ходе его работы. 

- Попадание элемента в окно - добавление в правый стек за **O(1)**.
- Перенос элемента из правого стека в левый - 
- **O(1)** на удаление из правого стека и на добавление в левый в методе `*throwOver`.
- Удаление элемента из окна - удаление из левого стека за **O(1)**.

Итого **O(1)** операций на каждый элемент в ходе работы алгоритма. Из этого следует, что при N элементов в списке временная сложность алгоритма - **O(N)**.

### Пространственная сложность
Пространственная сложность этого решения составляет **O(k)**, где k — ширина скользящего окна, без учета памяти на формирование списка с ответом.

Это так, потому что в каждый момент времени работы алгоритма мы храним в обоих стеках суммарно k элементов. Те элементы которые выходят из окна - удаляются из стека и собираются Garbage Collector'ом, а элементы еще не вошедшие в окно - очевидно в список не входят.